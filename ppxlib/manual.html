<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>manual (ppxlib.manual)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">ppxlib</a> &#x00BB; manual</nav><header class="odoc-preamble"><h1 id="ppxlib's-manual"><a href="#ppxlib's-manual" class="anchor"></a>Ppxlib's manual</h1></header><nav class="odoc-toc"><ul><li><a href="#what-is-ppx">What is ppx</a><ul><li><a href="#overview">Overview</a></li><li><a href="#how-does-it-works?">How does it works?</a></li><li><a href="#is-ppxlib-necessary?">Is ppxlib necessary?</a></li><li><a href="#current-state-of-the-ppx-ecosystem">Current state of the ppx ecosystem</a></li><li><a href="#note-on-stability-regarding-new-compiler-releases">Note on stability regarding new compiler releases</a></li></ul></li><li><a href="#ppxlib-for-end-users">PPX for end users</a><ul><li><a href="#using-a-ppx-rewriter-in-your-project">Using a ppx rewriter in your project</a></li><li><a href="#looking-at-the-generated-code">Looking at the generated code</a></li><li><a href="#@@deriving_inline"><code>@@deriving_inline</code></a></li><li><a href="#dropping-ppx-dependencies-with-@@deriving_inline">Dropping ppx dependencies with <code>@@deriving_inline</code></a></li></ul></li><li><a href="#ppxlib-for-plugin-authors">PPX for plugin authors</a><ul><li><a href="#getting-started">Getting started</a><ul><li><a href="#the-ocaml-ast">The OCaml AST</a></li><li><a href="#writing-an-extension-rewriter">Writing an extension rewriter</a></li><li><a href="#writing-a-deriver">Writing a deriver</a></li></ul></li><li><a href="#metaquot">Metaquot</a></li><li><a href="#handling-errors">Handling errors</a><ul><li><a href="#embedding-the-errors-in-the-ast">Embedding the errors in the AST</a></li><li><a href="#a-documented-example">A documented example</a></li><li><a href="#in-case-of-panic">In case of panic</a></li><li><a href="#migrating-from-raising-to-embedding-errors">Migrating from raising to embedding errors</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="what-is-ppx"><a href="#what-is-ppx" class="anchor"></a>What is ppx</h2><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>Ppx is a meta-programming system for the OCaml programming language. It allows developers to generate code at compile time in a principled way. The distinguishing feature of ppx is that it is tightly integrated with the OCaml parser and instead of operating at the text level it operates on the internal structured representation of the language in the compiler, called the Abstract Syntax Tree or AST for short.</p><p>A few years ago, the OCaml language was extended with two new constructions: annotations and extension points. Annotations are arbitrary pieces of information that can be attached to most parts of the OCaml language. They can be used to control the behavior of the OCaml compiler, or in some specific cases to generate code at compile time.</p><p>Extension points are compile time functions. The compiler itself doesn't know how to interpret them and they must all be rewritten by the ppx system before the compiler can process input files further.</p><p>Ppxlib mainly supports two ways of generating code at compile time: by expanding an extension point or by expanding a <code>[@@deriving ...]</code> attribute after a type declaration.</p><h3 id="how-does-it-works?"><a href="#how-does-it-works?" class="anchor"></a>How does it works?</h3><p>The ppx system is composed of 3 parts:</p><ul><li>individual ppx rewriters</li><li>ppxlib</li><li>a hook in the compiler</li></ul><p>Individual ppx rewriters are those implemented by various developers to provide features to end users, such as <a href="https://github.com/janestreet/ppx_expect">ppx_expect</a> which provides a good inline testing framework.</p><p>All these rewriters are written against the ppxlib API. Ppxlib is responsible for acknowledging the various rewriters an end user wants to use, making sure they can be composed together and performing the actual rewriting of input files.</p><p>The hook in the compiler allows ppxlib to insert itself in the compilation pipeline and perform the rewriting of input files based on a list of ppx rewriters specified by the user. The hooks take the form of command line flags that take a command to execute. The compiler supports two slightly different flags, for providing commands that are executed at different stages: <code>-pp</code> and <code>-ppx</code>. The difference between the two is as follow:</p><ul><li><code>-pp</code> takes as argument a command that is used to parse the textual representation. Such a command can produce either a plain OCaml source file or a serialised representation of the AST</li></ul><ul><li><code>-ppx</code> takes as argument a command that is given a serialised representation of the AST and produces another serialised AST</li></ul><p>Ppxlib generally uses the first one as it yields faster compilation times, however it supports both methods of operation.</p><h3 id="is-ppxlib-necessary?"><a href="#is-ppxlib-necessary?" class="anchor"></a>Is ppxlib necessary?</h3><p>Yes. While authors of ppx rewriters may in theory use the compiler hooks directly, doing so is strongly discouraged for the following reasons:</p><ul><li>composing such ppx rewriters is slow and yields much slower compilation times</li><li>the ABI of the hook is not stable and regularly changes in incompatible ways. This means that a ppx rewriter using the compiler hook directly is likely to work only with a single version of the OCaml compiler</li><li>the compiler does not provide good composition semantics, which means that input files will not always be transformed as expected. It is hard to predict what the final result will be, and for end users it is hard to understand what is happening when things go wrong</li><li>the compiler doesn't handle hygiene: if an attribute is mistyped or misplaced, it is silently ignored by the compiler. If two ppx rewriters want to interpret the same attribute or extension point in incompatible ways, the result is not specified</li></ul><p>In summary, ppxlib abstracts away the low-level details of the ppx system and exposes a consistent model to authors of ppx rewriters and end users.</p><h3 id="current-state-of-the-ppx-ecosystem"><a href="#current-state-of-the-ppx-ecosystem" class="anchor"></a>Current state of the ppx ecosystem</h3><p>Ppxlib was developed after the introduction of the ppx system. As a result, many ppx rewriters do not currently use ppxlib and are using the compiler hooks directly. Ppxlib can acknowledge such rewriters so that they can be used in conjunction with more modern rewriters, however it cannot provide a good composition or hygiene story when using such ppx rewriters.</p><h3 id="note-on-stability-regarding-new-compiler-releases"><a href="#note-on-stability-regarding-new-compiler-releases" class="anchor"></a>Note on stability regarding new compiler releases</h3><p>Due to the nature of the ppx system, it is hard for ppxlib to provide full protection against compiler changes. This means that a ppx rewriter written against ppxlib today can be broken by a future release of the OCaml compiler and a new release of the ppx rewriter will be necessary to support the new compiler.</p><p>However the following is true: every time this might happen, it will be possible to extend ppxlib to provide a greater protection, so that eventually the whole ppx ecosystem is completely shielded from breaking compiler changes.</p><h2 id="ppxlib-for-end-users"><a href="#ppxlib-for-end-users" class="anchor"></a>PPX for end users</h2><p>This section describes how to use ppx rewriters for end users.</p><h3 id="using-a-ppx-rewriter-in-your-project"><a href="#using-a-ppx-rewriter-in-your-project" class="anchor"></a>Using a ppx rewriter in your project</h3><p>To use one or more ppx rewriters written by you or someone else, simply list them in the <code>preprocess</code> field of your <code>dune</code> file. For instance:</p><pre class="language-ocaml"><code>(library
 (name my_lib)
 (preprocess (pps (ppx_sexp_conv ppx_expect))))</code></pre><p>Some ppx rewriters takes parameters in the form of command line flags. These can be specified using the usual convention for command line flags: atoms starting with <code>-</code> are treated as flags and <code>--</code> can be used to separate ppx rewriter names from more command line flags. For instance:</p><pre class="language-ocaml"><code>(library
 (name my_lib)
 (preprocess
  (pps (ppx_sexp_conv ppx_expect -inline-test-drop))))

(library
 (name my_lib)
 (preprocess
  (pps (ppx_sexp_conv ppx_expect -- --cookie &quot;x=42&quot;))))</code></pre><p>Once this is done, you can use whatever feature is offered by the ppx rewriter.</p><h3 id="looking-at-the-generated-code"><a href="#looking-at-the-generated-code" class="anchor"></a>Looking at the generated code</h3><p>At the time of writing this manual, there is no easy way to look at the fully transformed input file in order to see exactly what will be compiled by OCaml. You can however use the following method, which is not great but works: run <code>ocamlc -dsource _build/default/&lt;input-file-with-.pp.ml-extension&gt;</code>. For instance to see the transformed version of <code>src/foo.ml</code>, run:</p><pre class="language-ocaml"><code>$ ocamlc -dsource _build/default/src/foo.pp.ml</code></pre><h3 id="@@deriving_inline"><a href="#@@deriving_inline" class="anchor"></a><code>@@deriving_inline</code></h3><p>Ppxlib supports attaching the <code>[@@deriving]</code> attribute to type declaration. This is used to generate code at compile time based on the structure of the type. For this particular case, ppxlib supports an alternative way to look at the generated code: replace <code>[@@deriving &lt;derivers&gt;]</code> by <code>[@@deriving_inline
&lt;derivers&gt;][@@@end]</code>. Then run the following command:</p><pre class="language-ocaml"><code>$ dune build --auto-promote</code></pre><p>If you reload the file in your editor, you should now see the contents of the generated code between the <code>[@@deriving_inline]</code> and <code>[@@@end]</code> attribute. This can help understanding what is provided by a ppx rewriter or debug compilation errors.</p><h3 id="dropping-ppx-dependencies-with-@@deriving_inline"><a href="#dropping-ppx-dependencies-with-@@deriving_inline" class="anchor"></a>Dropping ppx dependencies with <code>@@deriving_inline</code></h3><p>You might notice that the resulting file when using <code>[@@deriving_inline]</code> needs no special treatment to be compiled. In particular, you can build it without the ppx rewriter or even ppxlib. You only need them while developing the project, in order to automatically produce the generated code but that's it. End users of your project do not need to install ppxlib and other ppx rewriters themselves.</p><p><a href="https://dune.build/">Dune</a> gracefully supports this workflow: simply replace <code>preprocess</code> in your <code>dune</code> file by <code>lint</code>. For instance:</p><pre class="language-ocaml"><code>(library
 (name my_lib)
 (lint (pps (ppx_sexp_conv))))</code></pre><p>Then to regenerate the parts between <code>[@@deriving_inline]</code> and <code>[@@@end]</code>, run the following command:</p><pre class="language-ocaml"><code>$ dune build @lint --auto-promote</code></pre><h2 id="ppxlib-for-plugin-authors"><a href="#ppxlib-for-plugin-authors" class="anchor"></a>PPX for plugin authors</h2><p>This section describes how to use <code>ppxlib</code> for PPX plugin authors.</p><h3 id="getting-started"><a href="#getting-started" class="anchor"></a>Getting started</h3><p>There are two main kinds of PPX plugins you can write with <code>ppxlib</code>:</p><ul><li>Extension rewriters i.e. ppx plugins that rewrite extension points such as <code>[%my_ext ...]</code> into valid OCaml code.</li><li>Derivers i.e. ppx plugins that generate code from type, module or exception declarations annotated with <code>[@@deriving my_deriver]</code>.</li></ul><p>It is also possible to write more advanced transformations such as rewriting constants that bear the right suffix, rewriting function calls based on the function identifier or to generate code from items annotated with a custom attribute but we won't cover those in this section.</p><p><code>ppxlib</code> compiles those transformations into rules which allows it to apply them to the right AST nodes, even recursively in nodes generated by other transformations, in a single AST traversal.</p><p>Note that you can also write arbitrary, whole AST transformations with ppxlib but they don't have a clear composition semantic since they have to be applied sequentially as opposed to the other, better defined rewriting rule. You should always prefer the above mentioned transformations instead when possible.</p><h4 id="the-ocaml-ast"><a href="#the-ocaml-ast" class="anchor"></a>The OCaml AST</h4><p>As described in <code>ppx-overview</code>, PPX rewriters don't operate at the text level but instead used the compiler's internal representation of the source code: the Abstract Syntax Tree or AST.</p><p>A lot of the following sections of the manual assume a certain level of familiarity with the OCaml AST so we'll try to cover the basics here and to give you some pointers to deepen your knowledge on the subject.</p><p>The types describing the AST are defined in the <code>Parsetree</code> module of OCaml's compiler-libs. Note that they vary from one version of the compiler to another so make sure you look at an up to date version and most importantly to the one corresponding to what ppxlib's using internally. You can find the module's API documentation online <a href="https://caml.inria.fr/pub/docs/manual-ocaml/compilerlibref/Parsetree.html">here</a>. If you're new to these parts of OCaml it's not always easy to navigate as it just contains the raw type declarations but no actual documentation. This documentation is actually written in <code>parsetree.mli</code> but not in a way that allows it to make its way to the online doc unfortunately. Until this is fixed in the compiler you can look at the local copy in one of your opam switches: <code>&lt;path-to-opam-switch&gt;/lib/ocaml/compiler-libs/parsetree.mli</code>. Here you'll find detailed explanations as to which part of the concrete syntax the various types correspond to.</p><p>Ppxlib includes a <code>Parsetree</code> module for every version of OCaml since <code>4.02</code>. For instance, the version for <code>4.05</code> is in <a href="Astlib/Ast_405/Parsetree/index.html"><code>Astlib.Ast_405.Parsetree</code></a>. In what comes next, we will link the values we describe to the <a href="Astlib/Ast_500/Parsetree/index.html"><code>Ppxlib.Parsetree</code></a> module, which corresponds to one version of <code>Parsetree</code>.</p><p><code>Parsetree</code> is quite a large module and there are plenty of types there, a lot of which you don't necessarily have to know when writing a rewriter. The two main entry points are the <code>structure</code> and <code>signature</code> types which, amongst other things, describe respectively the content of <code>.ml</code> and <code>.mli</code> files. Other types you should be familiar with are:</p><ul><li><a href="Astlib/Ast_500/Parsetree/index.html#type-expression"><code>expression</code></a> which describes anything in OCaml that evaluates to a value, the right hand side of a let binding or the branches of an if-then-else for instance. - <a href="Astlib/Ast_500/Parsetree/index.html#type-pattern"><code>pattern</code></a> which is what you use to deconstruct an OCaml value, the left hand side of a let binding or a pattern-matching case for example. - <a href="Astlib/Ast_500/Parsetree/index.html#type-core_type"><code>core_type</code></a> which describes type expressions ie what you use to explicitly constrain the type of an expression or describe the type of a value in your <code>.mli</code> files. Usually it's what comes after a <code>:</code>. - <a href="Astlib/Ast_500/Parsetree/index.html#type-structure_item"><code>structure_item</code></a> and <a href="Astlib/Ast_500/Parsetree/index.html#type-signature_item"><code>signature_item</code></a> which describe the top level AST nodes you can find in a structure or signature such as type definitions, value declarations or module declarations.</li></ul><p>Knowing what these types correspond to puts you in a good position to write a PPX plugin as they are the parts of the AST you will deal with the most in general.</p><h4 id="writing-an-extension-rewriter"><a href="#writing-an-extension-rewriter" class="anchor"></a>Writing an extension rewriter</h4><p>To write your ppx plugin you'll need to add the following stanza in your dune file:</p><pre class="language-ocaml"><code>(library
 (public_name my_ppx_rewriter)
 (kind ppx_rewriter)
 (libraries ppxlib))</code></pre><p>You'll note that you have to let dune know this is not a regular library but a ppx_rewriter using the <code>kind</code> field. The public name you chose here is the name your users will refer to your ppx in there <code>preprocess</code> field. E.g. here to use this ppx rewriter one would add the <code>(preprocess (pps my_ppx_rewriter))</code> to their <code>library</code> or <code>executable</code> stanza.</p><p>You will also need the following <code>my_ppx_rewriter.ml</code>:</p><pre class="language-ocaml"><code>open Ppxlib

let expand ~ctxt payload =
  ...

let my_extension =
  Extension.V3.declare
    &quot;my_ext&quot;
    &lt;extension_context&gt;
    &lt;ast_pattern&gt;
    expand

let rule = Ppxlib.Context_free.Rule.extension my_extension

let () =
  Driver.register_transformation
    ~rules:[rule]
    &quot;my_ext&quot;</code></pre><p>There are a few things to explain here. The last part, i.e. the call to <a href="Ppxlib/Driver/index.html#val-register_transformation"><code>Driver.register_transformation</code></a> is common to almost all ppxlib-based PPX plugins and is how you let <code>ppxlib</code> know about your transformation. You'll note that here we register a single rule but it is possible to register several rules for a single logical transformation.</p><p>The above is specific to extension rewriters. You need to declare a ppxlib <a href="Ppxlib/Extension/index.html"><code>Extension</code></a>. The first argument is the extension name, that's what will appear after the <code>%</code> in the extension point when using your rewriter, e.g. here this will transform <code>[%my_ext ...]</code> nodes. The <code>&lt;extension_context&gt;</code> argument describes where in OCaml code your this extension can be used. You can find the full list in the API documentation in the <a href="Ppxlib/Extension/Context/index.html"><code>Extension.Context</code></a> module. The <code>&lt;ast_pattern&gt;</code> argument helps you restrict what users can put into the payload of your extension, i.e. <code>[%my_ext &lt;what goes there!&gt;]</code>. We cover <a href="Ppxlib/Ast_pattern/index.html"><code>Ast_pattern</code></a> in depths here but the simplest form it can take is <a href="Ppxlib/Ast_pattern/index.html#val-__"><code>Ast_pattern.__</code></a> which allows any payload allowed by the language and passes it to the expand function which is the last argument here. The expand function is where the logic for your transformation is implemented. It receives an <a href="Ppxlib/Expansion_context/Extension/index.html#type-t"><code>Expansion_context.Extension.t</code></a> argument labelled <code>ctxt</code> and other arguments whose type and number depends on the <code>&lt;ast_pattern&gt;</code> argument. The return type of the function is determined by the <code>&lt;extension_context&gt;</code> argument, e.g. in the following example:</p><pre class="language-ocaml"><code>Extension.V3.declare &quot;my_ext&quot; Extension.Context.expression Ast_pattern.__ expand</code></pre><p>The type of the <code>expand</code> function is:</p><pre class="language-ocaml"><code>val expand : ctxt: Expansion_context.Extension.t -&gt; payload -&gt; expression</code></pre><p>If you want to look at a concrete example of extension rewriter you can find one in the <code>examples/</code> folder of the <code>ppxlib</code> repository <a href="https://github.com/ocaml-ppx/ppxlib/tree/main/examples/simple-extension-rewriter">here</a>.</p><h4 id="writing-a-deriver"><a href="#writing-a-deriver" class="anchor"></a>Writing a deriver</h4><p>Similarly to extension rewriters, derivers must be declared as such to dune. To do so you can use the following stanza in your dune file:</p><pre class="language-ocaml"><code>(library
 (public_name my_ppx_deriver)
 (kind ppx_deriver)
 (libraries ppxlib))</code></pre><p>Same as above, the public name used here determines how users will refer to your ppx deriver in their dune stanzas.</p><p>You will also need the following <code>my_ppx_deriver.ml</code>:</p><pre class="language-ocaml"><code>open Ppxlib

let generate_impl ~ctxt (rec_flag, type_declarations) =
  ...

let generate_intf ~ctxt (rec_flag, type_declarations) =
  ...

let impl_generator = Deriving.Generator.V2.make_noarg generate_impl

let intf_generator = Deriving.Generator.V2.make_noarg generate_intf

let my_deriver =
  Deriving.add
    &quot;my_deriver&quot;
    ~str_type_decl:impl_generator
    ~sig_type_decl:intf_generator</code></pre><p>The call to <a href="Ppxlib/Deriving/index.html#val-add"><code>Deriving.add</code></a> is how you'll let <code>ppxlib</code> know about your deriver. The first string argument is the name of the deriver as referred to by your users, in the above example one would add a <code>[@@deriving
my_deriver]</code> annotation to use this plugin. Here our deriver can be used on type declarations, be it in structures or signatures (i.e. implementation or interfaces, <code>.ml</code> or <code>.mli</code>).</p><p>To add a deriver you first have to define a generator. You need one for each node you want to derive code from. Here we just need one for type declarations in structures and one for type declarations in signatures. To do that you need the <a href="Ppxlib/Deriving/Generator/V2/index.html#val-make_noarg"><code>Deriving.Generator.V2.make_noarg</code></a> constructor. You'll note that there exists <a href="Ppxlib/Deriving/Generator/V2/index.html#val-make"><code>Deriving.Generator.V2.make</code></a> variant if you wish to allow passing arguments to your deriver but to keep this tutorial simple we won't cover this here. The only mandatory argument to the constructor is a function which takes a labelled <span class="xref-unresolved"><code>Expansion_context.Deriving.t</code></span>, an <code>'input_ast</code> and returns an <code>'output_ast</code> and that will give us a <code>('output_ast,
'input_ast) Deriving.Generator.t</code>. Much like the <code>expand</code> function described in the section about extension rewriters, this function is where the actual implementation for your deriver lives. The <code>str_type_decl</code> argument of <a href="Ppxlib/Deriving/index.html#val-add"><code>Deriving.add</code></a> expects a <code>(structure, rec_flag *
type_declaration list) Generator.t</code> so our <code>generate_impl</code> function must take a pair <code>(rec_flag, type_declaration list)</code> and return a <code>structure</code> i.e. a <code>structure_item list</code>, for instance a list of function or module declaration. The same goes for the <code>generate_intf</code> function except that it must return a <code>signature</code>. It is often the case that a deriver has a generator for both the structure and signature variants of a node. That allows users to generate the signature corresponding to the code generated by the deriver in their <code>.ml</code> files instead of having to type it and maintain it themselves.</p><p>If you want to look at a concrete example of deriver you can find one in the <code>examples/</code> folder of the <code>ppxlib</code> repository <a href="https://github.com/ocaml-ppx/ppxlib/tree/main/examples/simple-deriver">here</a>.</p><h3 id="metaquot"><a href="#metaquot" class="anchor"></a>Metaquot</h3><p><code>metaquot</code> is a PPX plugin that helps you write PPX plugins. It lets you write AST node values using the actual corresponding OCaml syntax instead of building them with the more verbose AST types or <code>Ast_builder</code>.</p><p>To use <code>metaquot</code> you need to add it to the list of preprocessor for your PPX plugin:</p><pre class="language-ocaml"><code>(library
 (name my_plugin_lib)
 (preprocess (pps ppxlib.metaquot)))</code></pre><p><code>metaquot</code> can be used both to write expressions of some of the AST types or to write patterns to match over those same types. The various extensions it exposes can be used in both contexts, expressions or patterns.</p><p>The extension you should use depends on the type of AST node you're trying to write or to pattern-match over. You can use the following extensions with the following syntax:</p><ul><li><code>expr</code> for <a href="Astlib/Ast_500/Parsetree/index.html#type-expression"><code>Parsetree.expression</code></a>: <code>[%expr 1 + 1]</code></li><li><code>pat</code> for <a href="Astlib/Ast_500/Parsetree/index.html#type-pattern"><code>Parsetree.pattern</code></a>: <code>[%pat? (&quot;&quot;, _)]</code></li><li><code>type</code> for <a href="Astlib/Ast_500/Parsetree/index.html#type-core_type"><code>Parsetree.core_type</code></a>: <code>[%type: int -&gt; string]</code></li><li><code>stri</code> for <a href="Astlib/Ast_500/Parsetree/index.html#type-structure_item"><code>Parsetree.structure_item</code></a>: <code>[%stri let a = 1]</code></li><li><code>sigi</code> for <a href="Astlib/Ast_500/Parsetree/index.html#type-signature_item"><code>Parsetree.signature_item</code></a>: <code>[%sigi: val i : int]</code></li><li><code>str</code> and <code>sig</code> respectively for <a href="Astlib/Ast_500/Parsetree/index.html#type-structure"><code>Parsetree.structure</code></a> and <a href="Astlib/Ast_500/Parsetree/index.html#type-signature"><code>Parsetree.signature</code></a>. They use similar syntax to the <code>_item</code> extensions above as they are just a list of such items.</li></ul><p>If you consider the first example <code>[%expr 1 + 1]</code>, in an expression context, <code>metaquot</code> will actually expand it into:</p><pre class="language-ocaml"><code>{
  pexp_desc =
    (Pexp_apply
       ({
          pexp_desc = (Pexp_ident { txt = (Lident &quot;+&quot;); loc });
          pexp_loc = loc;
          pexp_attributes = []
        },
         [(Nolabel,
            {
              pexp_desc = (Pexp_constant (Pconst_integer (&quot;1&quot;, None)));
              pexp_loc = loc;
              pexp_attributes = []
            });
         (Nolabel,
           {
             pexp_desc = (Pexp_constant (Pconst_integer (&quot;1&quot;, None)));
             pexp_loc = loc;
             pexp_attributes = []
           })]));
  pexp_loc = loc;
  pexp_attributes = []
}</code></pre><p>For this to compile you need the AST types to be in the scope so you should always use <code>metaquot</code> where <code>Ppxlib</code> is opened. You'll also note that the generated node expects a <code>loc : Location.t</code> value to be available. The produced AST node value and every other nodes within it will be located to <code>loc</code>. You should make sure <code>loc</code> is the location you want for your generated code when using <code>metaquot</code>.</p><p>When using the pattern extension, it will produce a pattern that matches no matter what the location and attributes are. For the previous example for instance, it will produce the following pattern:</p><pre class="language-ocaml"><code>{
  pexp_desc =
    (Pexp_apply
       ({
          pexp_desc = (Pexp_ident { txt = (Lident &quot;+&quot;); loc = _ });
          pexp_loc = _;
          pexp_attributes = _
        },
         [(Nolabel,
            {
              pexp_desc = (Pexp_constant (Pconst_integer (&quot;1&quot;, None)));
              pexp_loc = _;
              pexp_attributes = _
            });
         (Nolabel,
           {
             pexp_desc = (Pexp_constant (Pconst_integer (&quot;1&quot;, None)));
             pexp_loc = _;
             pexp_attributes = _
           })]));
  pexp_loc = _;
  pexp_attributes = _
}</code></pre><p>Using these extensions alone, you can only produce constant/static AST nodes. You can't bind variables in the generated patterns either. <code>metaquot</code> has a solution for that as well: anti-quotation. You can use anti-quotation to insert any expression or pattern representing an AST node. That way you can include dynamically generated nodes inside a <code>metaquot</code> expression extension point or use a wildcard or variable pattern in a pattern extension.</p><p>Consider the following example:</p><pre class="language-ocaml"><code>let with_suffix_expr ~loc s =
  let dynamic_node = Ast_builder.Default.estring ~loc s in
  [%expr [%e dynamic_node] ^ &quot;some_fixed_suffix&quot;]</code></pre><p>The <code>with_suffix_expr</code> function will create an <code>expression</code> which is the concatenation of the <code>s</code> argument and the fixed suffix. I.e. <code>with_suffix_expr
&quot;some_dynamic_stem&quot;</code> is equivalent to <code>[%expr &quot;some_dynamic_steme&quot; ^
&quot;some_fixed_suffix&quot;]</code>.</p><p>Similarly if you want to ignore some parts of AST nodes and extract some others when pattern-matching over them, you can use anti-quotation:</p><pre class="language-ocaml"><code>match some_expr_node with
| [%expr 1 + [%e? _] + [%e? third]] -&gt; do_something_with third</code></pre><p>The syntax for anti-quotation depends on the type of the node you wish to insert:</p><ul><li><code>e</code> to anti-quote values of type <a href="Astlib/Ast_500/Parsetree/index.html#type-expression"><code>Parsetree.expression</code></a>: <code>[%expr 1 + [%e some_expr_node]]</code></li><li><code>p</code> to anti-quote values of type <a href="Astlib/Ast_500/Parsetree/index.html#type-pattern"><code>Parsetree.pattern</code></a>: <code>[%pat? (1, [%p some_pat_node])]</code></li><li><code>t</code> to anti-quote values of type <a href="Astlib/Ast_500/Parsetree/index.html#type-core_type"><code>Parsetree.core_type</code></a>: <code>[%type: int -&gt; [%t some_core_type_node]]</code></li><li><code>m</code> to anti-quote values of type <a href="Astlib/Ast_500/Parsetree/index.html#type-module_expr"><code>Parsetree.module_expr</code></a> or <a href="Astlib/Ast_500/Parsetree/index.html#type-module_type"><code>module_type</code></a>: <code>[%expr let module M = [%m some_module_expr_node]]</code> or <code>[%sigi: module M : [%m some_module_type_node]]</code></li><li><code>i</code> to anti-quote values of type <a href="Astlib/Ast_500/Parsetree/index.html#type-structure_item"><code>Parsetree.structure_item</code></a> or <a href="Astlib/Ast_500/Parsetree/index.html#type-signature_item"><code>signature_item</code></a>: <code>[%str let a = 1 [%%i some_structure_item_node]]</code> or <code>[%sig: val a : int [%%i some_signature_item_node]]</code></li></ul><p>Note that when anti-quoting in a pattern context you must always use the <code>?</code> in the anti-quotation extension as its payload should always be a pattern the same way it must always be an expression in an expression context.</p><p>As you may have noticed, you can anti-quote expressions which type differs from the type of the whole <code>metaquot</code> extension point. E.g. you can write:</p><pre class="language-ocaml"><code>let structure_item =
  [%stri let [%p some_pat] : [%t some_type] = [%e some_expr]]</code></pre><h3 id="handling-errors"><a href="#handling-errors" class="anchor"></a>Handling errors</h3><p>In order to give a nice user experience when reporting errors or failures in a ppx, it is necessary to include as much of the generated content as possible. Most IDE tools, such as Merlin, rely on the AST for their features, such as displaying type, jumping to definition or showing the list of errors.</p><h4 id="embedding-the-errors-in-the-ast"><a href="#embedding-the-errors-in-the-ast" class="anchor"></a>Embedding the errors in the AST</h4><p>A common way to report an error is to throw an exception. However, this method interrupts the execution flow of the ppxlib driver and leaves later PPX's unexpanded when handing the AST over to merlin.</p><p>Instead, it is better to always return a valid AST, as complete as possible, but with &quot;error extension nodes&quot; at every place where successful code generation was impossible. Error extension nodes are special extension nodes <code>[%ocaml.error error_message]</code>, which can be embedded into a valid AST and are interpreted later as errors, for instance by the compiler or Merlin. As all extension nodes, they can be put <a href="https://ocaml.org/manual/extensionnodes.html">at many places in the AST</a>, to replace for instance structure items, expressions or patterns.</p><p>So whenever you're in doubt if to throw an exception or if to embed the error as an error extension node when writing a ppx rewriter, the answer is most likely: embed the error is the way to go! And whenever you're in doubt about where exactly inside the AST to embed the error, a good rule of thumb is: as deep in the AST as possible.</p><p>For instance, suppose a rewriter is supposed to define a new record type, but there is an error in the generation of the type of one field. In order to have the most complete AST as output, the rewriter can still define the type and all of its fields, putting an extension node in place of the type of the faulty field:</p><pre class="language-ocaml"><code>type long_record = {
  field_1: int;
  field_2: [%ocaml.error &quot;field_2 could not be implemented due to foo&quot;];
}</code></pre><p>Ppxlib provides a function in its API to create error extension nodes: <a href="Ppxlib/Location/index.html#val-error_extensionf"><code>error_extensionf</code></a>. This function creates an extension node, which has then to be transformed in the right kind of node using functions such as for instance <a href="Ppxlib/Ast_builder/Default/index.html#val-pexp_extension"><code>pexp_extension</code></a>.</p><h4 id="a-documented-example"><a href="#a-documented-example" class="anchor"></a>A documented example</h4><p>Let us give an example. We will define a deriver on types records, which constructs a default value from a given type. For instance, the derivation on the type <code>type t = { x:int; y: float; z: string}</code> would yield <code>let default_t = {x= 0; y= 0.; z= &quot;&quot;}</code>. This deriver has two limitations:</p><ol><li>It does not work on other types than records,</li><li>It only works for records containing fields of type <code>string</code>, <code>int</code> or <code>float</code>.</li></ol><p>The rewriter should warn the user about these limitations with a good error reporting. Let us first look at the second point. Here is the function mapping the fields from the type definition to a default expression.</p><pre class="language-ocaml"><code>let create_record ~loc fields =
  let declaration_to_instantiation (ld : label_declaration) =
    let loc = ld.pld_loc in
    let { pld_type; pld_name; _ } = ld in
    let e =
      match pld_type with
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;string&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_string (&quot;&quot;, loc, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;int&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_integer (&quot;0&quot;, None))
      | { ptyp_desc = Ptyp_constr ({ txt = Lident &quot;float&quot;; _ }, []); _ } -&gt;
          pexp_constant ~loc (Pconst_float (&quot;0.&quot;, None))
      | _ -&gt;
          pexp_extension ~loc
          @@ Location.error_extensionf ~loc
               &quot;Default value can only be derived for int, float, and string.&quot;
    in
    ({ txt = Lident pld_name.txt; loc }, e)
  in
  let l = List.map fields ~f:declaration_to_instantiation in
  pexp_record ~loc l None</code></pre><p>When the record definition contains several fields with types other than <code>int</code>, <code>float</code> or <code>string</code>, several error nodes are added in the AST. Moreover, the location of the error nodes corresponds to the definition of the record fields. This allows tools such as Merlin to report all errors at once, at the right location, resulting in a better workflow than having to recompile everytime one error is corrected to see the next one.</p><p>The first limitation is that the deriver cannot work on non record types. However, we decided here to derive a default value even in the case of non-record types, so that it does not appear as undefined in the remaining of the file. This impossible value consists of an error extension node.</p><pre class="language-ocaml"><code>let generate_impl ~ctxt (_rec_flag, type_declarations) =
  let loc = Expansion_context.Deriver.derived_item_loc ctxt in
  List.map type_declarations ~f:(fun (td : type_declaration) -&gt;
      let e, name =
        match td with
        | { ptype_kind = Ptype_record fields; ptype_name; ptype_loc; _ } -&gt;
            (create_record ~loc:ptype_loc fields, ptype_name)
        | { ptype_name; ptype_loc; _ } -&gt;
            ( pexp_extension ~loc
              @@ Location.error_extensionf ~loc:ptype_loc
                   &quot;Cannot derive accessors for non record type %s&quot;
                   ptype_name.txt,
              ptype_name )
      in
      [
        pstr_value ~loc Nonrecursive
          [
            {
              pvb_pat = ppat_var ~loc { txt = &quot;default_&quot; ^ name.txt; loc };
              pvb_expr = e;
              pvb_attributes = [];
              pvb_loc = loc;
            };
          ];
      ])
  |&gt; List.concat</code></pre><h4 id="in-case-of-panic"><a href="#in-case-of-panic" class="anchor"></a>In case of panic</h4><p>In some rare cases, it might happen that a whole file rewriter is not able to output a meaningful AST. In this case, they might be tempted to raise a located error: an exception that includes the location of the error. Moreover, this h as historically been what was suggested to do by ppxlib examples, but is now discouraged in most of the cases, as it prevents Merlin features to work well.</p><p>If such an exception is uncaught, the ppx driver will return with an error code and the exception will be pretty-printed, including the location (that's the case when the driver is called by dune). When the driver is spawned with the <code>-embed-errors</code> or <code>-as-ppx</code> flags (that's the case when the driver is called by merlin), the driver will look for located error. If it catches one, it will stop its chain of rewriting at this point, and output an AST consisting of the located error followed by the last valid AST: the one passed to the raising rewriter.</p><p>Even more in context-free rewriters, raising should be avoided, in favour of outputting a single error node when a finer grained reporting is not needed or possible. As the whole context-free rewriting is done in one traverse of the AST, a single raise will cancel both the context-free pass and upcoming rewriters, and the AST prior to the context-free pass will be outputted together with the error.</p><p>The function provided by the API to raise located errors is <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a>.</p><h4 id="migrating-from-raising-to-embedding-errors"><a href="#migrating-from-raising-to-embedding-errors" class="anchor"></a>Migrating from raising to embedding errors</h4><p>Lots of ppx-es exclusively use <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a> to report errors, instead of the more merlin friendly way consisting of embedding errors in the AST, as described in this section.</p><p>If you want to migrate such a codebase to the embedding approach, here are a few recipes to do that. Indeed, it might not be completely trivial, as raising can be done anywhere in the code, including in places where &quot;embedding&quot; would not make sense. What you can do is to turn your internal raising functions to function returning a <code>result</code> type.</p><p>The workflow for this change would look like this:</p><ol><li>Search through your code all uses of <a href="Ppxlib/Location/index.html#val-raise_errorf"><code>raise_errorf</code></a>, using for instance <code>grep</code>.</li><li>For each of them, turn them into function returning a <code>(_, extension) result</code> type, using <a href="Ppxlib/Location/index.html#val-error_extensionf"><code>error_extensionf</code></a> to generate the <code>Error</code>.</li><li>Let the compiler or merlin tell you where you need to propagate the <code>result</code> type (most certainly using <code>map</code>s and <code>bind</code>s).</li><li>When you have propagated until a point where you can, embed the extension in case of <code>Error extension</code>.</li></ol><p>This is quite convenient, as it allows you to do a &quot;type-driven&quot; modification, using at full the static analysis of OCaml to never omit a special case, and to confidently find the place the most deeply in the AST to embed the error. However, it might induces quite a lot of code modification, and exceptions are sometimes convenient to use, depending on the taste. In case you want to do only a very simple to keep using exception, catch them and turn them into extension points embedded in the AST, here is an example:</p><pre class="language-ocaml"><code>let rewrite_extension_point loc payload =
  try generate_ast payload
  with exn -&gt;
    let get_error exn =
      match Location.Error.of_exn exn with
      | None -&gt; raise exn
      | Some error -&gt; error
    in
    let extension = exn |&gt; get_error |&gt; Location.Error.to_extension in
    Ast_builder.Default.pstr_extension ~loc ext []</code></pre></div></body></html>